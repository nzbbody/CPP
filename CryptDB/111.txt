mysql key,unique key,primary key的区别
#####################################################################################################################

#####################################################################################################################
linux 计划任务

#####################################################################################################################
open与fopen



#####################################################################################################################
NAT DR TUN

#####################################################################################################################
Mysql 索引



#####################################################################################################################
编码的奥秘

#####################################################################################################################
mysql 备份还原


#####################################################################################################################
mysql半同步


#####################################################################################################################
primary key与unique的区别 大头爸爸的博

#####################################################################################################################
一次非常有意思的sql优化经历

#####################################################################################################################
博客园技术系列文章目录
TCP/IP详解

#####################################################################################################################
mysql 区分大小写





#####################################################################################################################
精度高

#####################################################################################################################
教你透彻了解红黑树


#####################################################################################################################
八大类算法原理


#####################################################################################################################
C++调用python解析xml

#####################################################################################################################
crud

#####################################################################################################################
mysql int与char为什么可以等同
mysql varchar(N)与int(N)的含义及其与char的区别


#####################################################################################################################
mysql 写入树形结构 读出树形结构
写入的时候，存储过程的参数能够传递集合吗？

#####################################################################################################################
线程驱动问题


#####################################################################################################################
otl sdk缓存没有取出来，mysql的原理


#####################################################################################################################
mysql 读锁与写锁，以及内部实现

 
#####################################################################################################################
mysql 查询执行的基础

#####################################################################################################################
mysql 数据库文件结构

#####################################################################################################################
tcp状态机 
syn_recv-->listen只有一条途径，那就是listen收到syn，到syn_recv，再收到rst，回到listen。
同时打开，进入syn_recv不可能收到rst，因为自己已经发了syn


#####################################################################################################################
localhost与127.0.0.1 之间的区别

mysql连接类型与socket通信原理
localhost与127.0.0.1的区别


#####################################################################################################################
tcp/ip详解源代码获取方法


#####################################################################################################################
霍夫曼编码



#####################################################################################################################
mysql 多列索引和多个单列索引
根据key_len判断使用哪个索引


#####################################################################################################################
mysql insert效率
1、大部分都是写少读多，比如代码，比如stl的集合的处理


#####################################################################################################################
C++ 偏特化

#####################################################################################################################
C++ 模板


#####################################################################################################################
mysql 外键关联，删除出错

#####################################################################################################################
C++ 模板

#####################################################################################################################
mysql 理解innodb_trx, innodb_locks, innodb_lock_waits

#####################################################################################################################
TCP/IP协议原理与应用


#####################################################################################################################
不定参数的理解

#####################################################################################################################
理解 sizeof




#####################################################################################################################
方法参数入栈为什么从右向左？
从右向左参数入栈方式原因之我见
C函数调用与入栈顺序
C和指针 看一下

#####################################################################################################################
默认形参为什么只能最右边？


#####################################################################################################################
理解printf 
1、参数从右向左入栈，参数在栈顶依次排列，栈顶是第一个参数。
2、格式化字符串标识了，把每次参数当成什么类型来解释，如果不匹配，会出现未定义错误。
3、


#####################################################################################################################
RST复位报文段
1、几种情况+已经写在博客里的
2、如何发送reset包

博客：几种TCP连接中出现RST的情况 360doc

#####################################################################################################################
telnet
telnet服务和客户端，开启telnet服务


#####################################################################################################################
线程同步信号量semaphore
windows CreateSemaphore,  ReleaseSemaphore,  WaitforSingleObject, WaitforMultipleObject

模拟场景，
1、一个生产者，一个消费者，共享缓冲区大小为1，
2、一个生产者，一个消费者，共享缓冲区大小为5（注：可以同时生产5个）
3、两个生产者，一个消费者，共享缓冲区大小为5（注：可以同时生产5个）

注意：可以同时生产5个，满了就不能生产了，这一点和tcp的滑动窗口类似。

另外信号量PV操作，可以表达语义：共享区没有了资源，消费者要等待。不能表达语义：共享区满了，生产者要等待。
也就是说，只有P操作要等待。
如果要表达，共享区满了，生产者要等待。需要使用反向的信号量。
sem_empty(0,5); 容量为5，可用数量为0，与共享缓冲区保持一致。只有sem_empty的情况，代码如下：

produce();
sem_empty.V();

sem_empty.P();
comsume();

加上一个反向的信号量。
sem_full(5,5); 容量为5，可用数量为5，与共享缓冲区相反。加上反向的信号量，代码如下：

sem_full.P();
produce();
sem_empty.V();

sem_empty.P();
comsume();
sem_full.V();





博客 
秒杀多线程第十篇 生产者消费者问题
旧时明月 生产者和消费者 实例


#####################################################################################################################
文档中最长的重复字符串


#####################################################################################################################
最长的公共字符串

#####################################################################################################################
打印出下面的内容
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
| 1  | SIMPLE      | student | ALL  | NULL          | NULL | NULL    | NULL | 5    |       |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+

#####################################################################################################################
python 默认加载的目录
import xxx 
import * from xxx


#####################################################################################################################
python 默认参数，为什么要搞出默认参数

#####################################################################################################################
大片的0,1 使用后面的数字表示0,1的个数


#####################################################################################################################
如何路由？ 目的ip地址不变，mac地址一直变化
tcp/ip 协议原理和应用


#####################################################################################################################
闻波，吃豆子过桥问题
其他的面试题


#####################################################################################################################
C++ 调用脚本 
popen
system
fork
exec
加上一个&
都测试一下




#####################################################################################################################
string转化为int


#####################################################################################################################
句柄和指针的区别

#####################################################################################################################
Linux的文件类型

#####################################################################################################################
每天一个Linux命令

traceroute
在路由器后面，traceroute返回一系列原因分析


#####################################################################################################################
MySQL主从复制的原理及配置方法（比较详细）


#####################################################################################################################
windows telnet

#####################################################################################################################
rpm 与 yun


#####################################################################################################################
验证锁的acquire和release


#####################################################################################################################
mysql M-S配置小记


#####################################################################################################################
对象池，用于解决协议的问题


#####################################################################################################################
Read_Master_Log_Pos 和 Exec_Master_Log_Pos
为什么有的相等，有的不相等，
Read_Master_Log_Pos是不是文件大小，还是文件中的位置
Exec_Master_Log_Pos是不是文件大小，还是文件中的位置


#####################################################################################################################
廖雪峰的官方教程 github教程


#####################################################################################################################
rpm



#####################################################################################################################
软件管理
rpm
yum


#####################################################################################################################
深入探索C++对象模型
1、字段，实例字段和静态字段
	布局 绑定 存取
2、静态方法和实例方法，虚方法
	调用方式

虚方法表中，第一个slot表示对象的类型，为什么需要这个slot表示对象的类型？
dynamic_cast进行强制类型转化，读取slot表示对象的类型。



#####################################################################################################################
项目
具备什么样的功能，做了什么工作，难点


#####################################################################################################################
system和popen为什么会卡住？
各种测试试一下
在10.36.65.10    /home/niu/localconfig


#####################################################################################################################
Linux系统调用
思维是自己的，代码改变世界



#####################################################################################################################
重点学习
Linux和内核  60个命令
Mysql 精通
TCP/IP
C++ 编程规范 101


#####################################################################################################################
libevent 代码研究


#####################################################################################################################
锁，信号量的实现
跨平台


#####################################################################################################################
Effective TCP_IP


#####################################################################################################################
目录管理
1、每个用户都有专属于自己的目录，自己访问。
2、在上层有一个共享目录，大家都能访问，在共享的地方放置头文件和共享的库。

#####################################################################################################################
telnet的功能，增加


#####################################################################################################################
矢量图和位图

#####################################################################################################################
vr有关的功能
1、录像分为中心录像和前端录像。
	中心录像：把码流文件保存在平台
	前端录像：把码流文件保存在前端设备DVR
2、中心录像：vru可以直连设备拉码流，也可以从vtdu拉码流
3、文件上传，换个角度看，也就是录像下载，也就是传输录像文件，可以是自己的fs服务器，ftp协议
4、录像回放，客户端录像回放，如果录像文件在客户端本地，直接拖到播放器即可。
	如果录像文件在服务端，需要vru打开录像文件，走一下rtsp流程。


#####################################################################################################################
C++ 获取工作目录 exe所在的路径


#####################################################################################################################
Mysql 先查询再分组，与先分组在查询的区别
使用子查询，也就是嵌套select



#####################################################################################################################
Run-Time Check Failure #2 - Stack around the variable 'msg' was corrupted.

莫名其妙的崩溃，原因是什么？


遇到这种莫名其妙的崩溃，怎么解决？
代码一点一点注释，找到崩溃的代码，缩小范围，定位到问题。


#####################################################################################################################
java C#为什么不需要头文件？


#####################################################################################################################
Mysql 试图


#####################################################################################################################
重要：调用别入的库，对于struct一定要初始化（一般使用memset初始化为0），千万不要依赖库的作者进行初始化。



#####################################################################################################################
列出文件大小
ll -h
du -s


#####################################################################################################################
Mysql语法
循环


#####################################################################################################################
值语义和指针语义


#####################################################################################################################
同步回调和异步回调

#####################################################################################################################
grep egrep扩展


#####################################################################################################################
zdump -v /etc/localtime
查看是否使用了夏令时



#####################################################################################################################
vru回放ps流



#####################################################################################################################
ivss不能浓缩，要重新编译IbpStreamParser vtdu_sdk
为什么有时候不能浓缩？
因为全是静态帧，没有移动的物体


#####################################################################################################################
vru有关的功能，
熟悉cqfs，ivss，M70

#####################################################################################################################
DOS攻击



#####################################################################################################################
watch命令



#####################################################################################################################
NTP原理补充

ntp同步状态
ntpstat和ntpq -p
需要5~10分钟

#####################################################################################################################
alias
取消别名


#####################################################################################################################
问题描述是：
	我们平台使用使用vms，间接和nvd0405解码器交互。设置墙，只有第一个屏可以上墙成功。第二个屏流程都是通的。
	对于第二个屏，需要在web客户端选择一下splitmode，然后就会上墙成功了。


#####################################################################################################################
拖延症
和管理方面很欠缺


####################################################################################################################
zookeeper

#####################################################################################################################
CryptDB

/home/niuzibin/work/cryptdb/bins/proxy-bin/bin/mysql-proxy --plugins=proxy --event-threads=4 --max-open-files=1024 --proxy-lua-script=$EDBDIR/mysqlproxy/wrapper.lua  --proxy-address=0.0.0.0:3307  --proxy-backend-addresses=localhost:3306

export EDBDIR=/home/niuzibin/work/cryptdb

mysql -uroot -pletmein -h127.0.0.1 -P3307


assert(package.loadlib(os.getenv("EDBDIR").."/obj/libexecute.so","lua_cryptdb_init"))()





#####################################################################################################################
修改了 .bashrc，如果要生效，需要重新登陆一下，或者 source一下，也就是source .bashrc



#####################################################################################################################
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| cryptdb_udf        |
| mysql              |
| performance_schema |
| remote_db          |
| yytest             |
+--------------------+
6 rows in set (0.00 sec)

mysql> use yytest;
ERROR 1105 (07000): Error: Failed to set default embedded database!
FILE: main/rewrite_util.cc
LINE: 560


错误原因是：以root身份，启动了proxy，导致访问目录 /home/niuzibin/work/cryptdb/shadow/embedded_db，出现异常

解决办法：在mysql删除，yytest，以niuzibin身份启动mysql，重新创建身份


#####################################################################################################################
niuzibin@ubuntu:~$ mysql -u root -pletmein -h127.0.0.1 -P3307
ERROR 1105 (HY000): #07000MySQL Proxy Lua script failed to load. Check the error log.

文件的所有者改为 niuzibin 








#####################################################################################################################
检查mysql的my.cnf权限
niuzibin@ubuntu:~$ sudo service mysql start     
start: Job failed to start


#####################################################################################################################
搞成不同的颜色
ruby


class String
    def cyan
        "\033[36m#{self}\033[0m"
    end

    def red
        "\033[31m#{self}\033[0m"
    end

    def bold
        "\033[1m#{self}\033[22m"
    end
end







#####################################################################################################################
mysql> select * from student where name like 'A%';
ERROR 1105 (07000): Identifier not found: 'oINVALID'
FILE: /home/niuzibin/work/heming/cryptdb/src/main/Analysis.cc
LINE: 783

:
SECURE_CRYPTDB
:
export SECURE_CRYPTDB=false

1、执行select * from student where name like 'A%'; 报错如下：
	ERROR 1105 (07000): Identifier not found: 'oINVALID'
	FILE: /home/niuzibin/work/heming/cryptdb/src/main/Analysis.cc
	LINE: 783
2、错误原因：
	为了支持加密后的多种运算，对于一个字段，需要创建多个字段表示，用于进行不同的运算。
	上面的查询使用 like，为了支持like，需要创建字段 xxxoPLAIN
	默认的情况下，不支持like，没有创建 xxxoPLAIN，导致上面的报错。
3、怎么解决上面的问题？
	支持like运算，需要设置环境变量 export SECURE_CRYPTDB=false
	然后重启proxy，再次创建一个表，可以看到多了一个字段 oPLAIN，支持like










#####################################################################################################################
mysql> select * from teacher where name like 'T_A%';     
ERROR 4095 (fail1): (/home/niuzibin/work/heming/cryptdb/src/main/rewrite_main.cc, 1670)
failed issuing adjustment completion

错误原因：
	第一次执行，没有加载啥玩意，在执行一次就OK了。




#####################################################################################################################
root ALL=(ALL) ALL
niuzibin  ALL=(ALL) NOPASSWD:ALL



#####################################################################################################################
加密用什么算法，加密的秘钥哪里来的？


#####################################################################################################################
CLion有时候断点不起作用，重新构建一下，再试一把，就OK了


#####################################################################################################################
RND纯粹为了加密用的，并不支持任何运算。



#####################################################################################################################
当前连接和其它连接，select的结果不一样
1、很大概率是没有提交，试一下commit


#####################################################################################################################
修改代码，在CLion构建，但是调试还是老的代码
1、原因是：CLion只做了构建这个步骤，生成libexecute.so，除了这个步骤还有一些东西，才能运行cryptdb。
2、使用我们自己的make是OK的，代码修改可以看到效果。


#####################################################################################################################
继续研究秘钥怎么来的
1、



#####################################################################################################################
CryptDB程序的入口
1、main_cmdline(argc, argv);
2、调用lua脚本处理客户端的请求

#####################################################################################################################
在哪里和mysql交互
1、我看看打印出来的结果，从哪里回调上来的？
	下面获取结果集，调用lua处理，lua塞给ConnectWrapper解密
	NETWORK_MYSQLD_CON_TRACK_TIME(con, "proxy::ready_query_result::enter_lua");
	ret = proxy_lua_read_query_result(con);
	NETWORK_MYSQLD_CON_TRACK_TIME(con, "proxy::ready_query_result::leave_lua");

#####################################################################################################################
在哪里发给客户端
1、

#####################################################################################################################
和lua的交互过程
1、站在ConnectWrapper的角度，lua塞进来原始的请求SQL，吐出来改写的SQL，塞进来加密的结果集，吐出来解密后的结果集。
2、站在MysqlProxy的角度，接收客户端的请求，塞给lua，返回来改写后的SQL，向Mysql请求执行，
	返回的结果，再次调用lua，如果不需要解密，lua直接返回，如果需要解密，lua塞给ConnectWrapper加密的结果，获得解密后的结果集。

#####################################################################################################################
秘钥的使用，举两个例子
1、insert
	insert into student(id ,name) value (1,"Andy");
	改写为
	insert into `yytest`.`table_DJOLFHGWZF` (`yytest`.`table_DJOLFHGWZF`.`LFIECAJCAJoEq`, `yytest`.`table_DJOLFHGWZF`.`QETERAMAWNoOrder`, `yytest`.`table_DJOLFHGWZF`.`FWJVAQHAQHoADD`, `yytest`.`table_DJOLFHGWZF`.`cdb_saltYWOEFKXAZA`, `yytest`.`table_DJOLFHGWZF`.`CLTXRKXDKWoEq`, `yytest`.`table_DJOLFHGWZF`.`SSUDPXUXXKoOrder`, `yytest`.`table_DJOLFHGWZF`.`cdb_saltADOKHQMSUN`) values (2423703893484115025, 4636867846941828899, '....\r..\\.n.$.=...2.|..M..p..2.5...\0........3.,.........XJ.%.......]...8.W6$.E...g.n.1..<.s.............Q.;.c......\\.4.WB"Q9j\Z[.Jg...l.\Zs....Y.x.~......+}.S...\\....[$....d.S.{...>...H..I-/HP..(Q...;.CC...i.c.......;.#:......E..*.o.\r.>`.kz....b.cY.uB.`.%I.D.', 4975926035299051736, '......Jx.....PXz..W{..g|.....$..i6K......K....#4', 9341831142585459103, 6835616390251316950)
2、要修改两个地方，字段扩展为多个字段，对扩展的字段，取值加密
	AbstractQueryExecutor *InsertHandler::rewrite
	对解析的LEX，做个副本，然后修改扩展的字段和取值。
3、select
	select * from student where id =2
	改写为
	select `yytest`.`table_YMJMSQZPLC`.`GNECUGHFKKoEq`,`yytest`.`table_YMJMSQZPLC`.`PJEOWBFZYOoEq`,`yytest`.`table_YMJMSQZPLC`.`cdb_saltVTHBXDHEJS` from `yytest`.`table_YMJMSQZPLC` where (`yytest`.`table_YMJMSQZPLC`.`GNECUGHFKKoEq` = 5911446623085300206)
4、要修改两个地方：
	rewrite_args_FN 对常数加密
	Rewriter::decryptResults，对select回来的结果解密
#####################################################################################################################
insert加密的值，调用堆栈
-->const auto &next_query = output.second;
-->const auto &output = std::get<1>(new_results)->extract<std::pair<bool, std::string> >();
-->const auto &new_results = qr->executor->next(res, nparams);

#####################################################################################################################
QueryRewrite类、Handler类、Executor类
1、Rewriter::dispatchOnLex 返回 Execute类
2、是怎么返回的？
	const SQLHandler &handler = dml_dispatcher->dispatch(lex);
	executor = handler.transformLex(a, lex);
3、WrapperState-->QueryRewrite-->Executor类
4、rewrite-->next-->得到重写后的sql语句，如果需要处理返回的结果集，还要再进来一次。
#####################################################################################################################
ModernCpp
move操作
1、解决什么问题？
	考虑下面的场景，甲乙住宾馆，甲对房间里面的家具不满意，对乙房间的家具满意，而乙因为其他原因退房。
2、怎么解决这个问题？
	笨的办法是，先清空甲房间的家具，对乙房间的每个家具复制一个，搬过来。
	这就是copy赋值的做法。
3、上面的办法，显然成本比较大。更好的办法是：
	把乙房间的钥匙给甲，不就OK了嘛，反正乙不再使用房间。
4、怎么实现？
	相对于上面的copy赋值，需要增加一种copy赋值，暂且叫做move转移赋值。
	为了区分正常的copy赋值，需要区分构造参数，也就是乙不再使用房间，也就是右值，期望接收右值参数。
	而move方法就是把左值参数，转化为右值参数。
5、注意：
	move只是把参数的属性修改一下，使它成为右值，触发调用接收右值参数的copy赋值，在copy赋值中，实现对钥匙的转移。
	copy构造也是相同的道理。
6、也就是说，增加了移动构造和移动赋值。
#####################################################################################################################
怎么样把秘钥搞成一个模块？




#####################################################################################################################
1、read_query
	read_query --> read_query_real --> next_handler --> CryptDB.next
	接收客户端的请求sql，进行转化，return proxy.PROXY_SEND_QUERY
	改写后的sql语句，通过 proxy.queries:append 传递过去。
2、read_query_result
	read_query_result --> read_query_result_real --> next_handler --> CryptDB.next
	接收mysql的返回，进行处理，return proxy.PROXY_SEND_RESULT
	处理后，如果有结果集需要返回，通过 proxy.response.resultset 传递过去。
3、proxy与mysql交互，从mysql返回之后，必定进入 read_query_result
	分为几种情况：
	a、不需要处理，比如 show databases; 直接返回
	b、只需要处理一次，比如 show tables; 解密一些表名即可
	c、需要处理多次，比如create table;
4、分析show databases;的流程：
	a、客户端发给proxy请求show databases，read_query接口返回PROXY_SEND_QUERY，同时传递改写后的sql语句，还是show databases
	b、内部的next接口返回query-results，把skip置为true
	b、proxy和mysql交互，从mysql收到响应包，在read_query_result_real检查到是skip，直接返回。
5、分析show tables;的流程：
	a、客户端发给proxy请求show tables，read_query接口返回PROXY_SEND_QUERY，同时传递改写后的sql语句，还是show tables
	b、内部的next接口返回again
	c、proxy和mysql交互，从mysql收到响应包，在read_query_result_real，打印响应的结果，然后 next_handler("results",
	d、next返回"results"，解密返回，return proxy.PROXY_SEND_RESULT，也就是说，先检查next的返回，再检查从哪里来的？
6、分析create table;的流程：
	a、客户端发给proxy请求create table，read_query接口返回PROXY_SEND_QUERY，同时传递改写后的sql语句，create tablexxx
	b、内部的next接口返回again
	c、proxy和mysql交互，从mysql收到响应包，在read_query_result_real，打印响应的结果，然后 next_handler("results",
	d、next返回"again"，告诉proxy忽略mysql的返回。
	e、proxy和mysql交互，从mysql收到响应包，next返回"results"
7、也就是说，
	第一次的改写返回PROXY_SEND_QUERY，
	中间过程的改写，返回PROXY_IGNORE_RESULT
	最后一步的处理，返回PROXY_SEND_RESULT
8、CryptDB.next的返回有三个值：
	again			要求proxy和mysql交互，并且再次进来，处理mysql的响应
	query-results	mysql的响应，到lua之后，lua直接返回
	results			返回最后处理的结果，要求proxy转发给客户端
9、proxy收到的回复有三个值：
	PROXY_SEND_QUERY 	向mysql发送请求
	PROXY_SEND_RESULT	向客户端发送最后的结果
	PROXY_IGNORE_RESULT	忽略中间过程的结果
10、总结一下，也就是说：
	第一步是改写，要求proxy和mysql交互，
	中间步骤处理返回的结果，比如剥洋葱，或者插入到remote_db，再次要求proxy和mysql交互，并且proxy忽略mysql的返回
	最后一步，改写mysql返回的结果集。

#####################################################################################################################
我先把流程改一下，试试


#####################################################################################################################
类的层次化结构
1、DBMeta是数据库的元数据类，子类MappedDBMeta是类模板，字段包括一个map结构，保存child数据结构。
2、MappedDBMeta会实例化一些模板类，比如MappedDBMeta<DatabaseMeta,IdentityMetaKey>，就是包含一组DatabaseMeta的集合
3、包含一组DatabaseMeta的集合，其实也就是 SchemaInfo，SchemaInfo继承 MappedDBMeta<DatabaseMeta,IdentityMetaKey>
4、DatabaseMeta、TableMeta、FieldMeta也是同样的道理。
5、TableMeta关注以下几个字段，分别为：
	counter 因为一个表的字段，是有顺序的，counter记录当前的counter值
	anon_table_name 是加密后的表名
	注意：IdentityMetaKey 是由明文的表名，序列化出来的
		  tm->addChild(IdentityMetaKey(name), std::move(fm));
	明文的表名-->IdentityMetaKey-->TableMeta-->anno_table_name
6、FieldMeta关注以下几个字段，分别为：
	fname 字段名称
	salt_name 前缀加上随机值
	onion_layout 是字段扩展后的洋葱，表示一个字段对应一组洋葱（map），以及每个洋葱对应的一组洋葱层（vector）。
7、OnionMeta不同于上面的结构，不是继承MappedDBMeta，而是直接继承DBMeta，因为OnionMeta直接关联vector的EncLayer，而不是map结构
	onionname是洋葱字段名称
8、EncLayer就是叶子结点，继承了LeafDBMeta，在LeafDBMeta中对叶子节点 do nothing
	EncLayer代表了一个加密层次的抽象
#####################################################################################################################
1、下面的代码做了什么事？
auto it =
    List_iterator<Create_field>(lex->alter_info.create_list);
new_lex->alter_info.create_list =
    accumList<Create_field>(it,
        [&a, &tm, &key_data] (List<Create_field> out_list,
                              Create_field *const cf) {
            return createAndRewriteField(a, cf, tm.get(),
                                         true, key_data, out_list);
    });
2、auto it =
    List_iterator<Create_field>(lex->alter_info.create_list);
	获取迭代器
3、调用方法accumList，返回List<Create_field> 给new_lex->alter_info.create_list
4、accumList是个方法模板，返回值是 list<Create_field>，参数有两个，list<Create_field>迭代器和一个方法 function
	accumList做的事情是，遍历迭代器，返回值作为，一直累加上去。
5、function是个方法模板，返回值是 list<Create_field>，参数有两个，list<Create_field>迭代器和Create_field指针，就是迭代器
	返回值调用 createAndRewriteField
#####################################################################################################################
git撤销修改
1、分为两种情况：
	第一种情况，工作区做了修改，还没有添加到暂存区。
	第二种情况，工作区做了修改，并且已经添加到暂存区，然后工作区又做了修改。
2、对于第一种情况，直接使用checkout即可。如下：
	niuzibin@ubuntu:~/work/gittest$ git status
	On branch master
	Changes not staged for commit:
	(use "git add <file>..." to update what will be committed)
	(use "git checkout -- <file>..." to discard changes in working directory)
	
			modified:   readme.txt
	
	no changes added to commit (use "git add" and/or "git commit -a")
	niuzibin@ubuntu:~/work/gittest$ git diff  
	diff --git a/readme.txt b/readme.txt
	index 4dd9cb5..56b6b46 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-I am Andy
	+I am Bill
	niuzibin@ubuntu:~/work/gittest$ git checkout readme.txt
	niuzibin@ubuntu:~/work/gittest$ git status
	On branch master
	nothing to commit, working directory clean
	niuzibin@ubuntu:~/work/gittest$ git diff
3、对于第二种情况，版本库是 I am Andy，暂存区是 I am Bill， 工作区是 I am Caroline，如下：
	// 比较暂存区和版本库的差别
	niuzibin@ubuntu:~/work/gittest$ git diff --cached
	diff --git a/readme.txt b/readme.txt
	index 4dd9cb5..56b6b46 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-I am Andy
	+I am Bill
	
	// 比较工作区和暂存区的差别
	niuzibin@ubuntu:~/work/gittest$ git diff
	diff --git a/readme.txt b/readme.txt
	index 56b6b46..b688830 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-I am Bill
	+I am Caroline
	
	// 比较工作区和版本库的差别
	niuzibin@ubuntu:~/work/gittest$ git diff HEAD
	diff --git a/readme.txt b/readme.txt
	index 4dd9cb5..b688830 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-I am Andy
	+I am Caroline
4、撤销工作区的修改，如下：
	niuzibin@ubuntu:~/work/gittest$ git checkout readme.txt
	niuzibin@ubuntu:~/work/gittest$ git diff --cached
	diff --git a/readme.txt b/readme.txt
	index 4dd9cb5..56b6b46 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-I am Andy
	+I am Bill
	niuzibin@ubuntu:~/work/gittest$ git diff
	niuzibin@ubuntu:~/work/gittest$ git diff HEAD          
	diff --git a/readme.txt b/readme.txt
	index 4dd9cb5..56b6b46 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-I am Andy
	+I am Bill
5、撤销暂存区的修改，如下：
	niuzibin@ubuntu:~/work/gittest$ git reset HEAD readme.txt
	Unstaged changes after reset:
	M       readme.txt
	niuzibin@ubuntu:~/work/gittest$ git diff --cached
	niuzibin@ubuntu:~/work/gittest$ git diff
	diff --git a/readme.txt b/readme.txt
	index 4dd9cb5..56b6b46 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-I am Andy
	+I am Bill
6、还需要再次checkout，如下：
	niuzibin@ubuntu:~/work/gittest$ git checkout readme.txt
	niuzibin@ubuntu:~/work/gittest$ git diff --cached
	niuzibin@ubuntu:~/work/gittest$ git diff
7、也就是说，checkout相当于拿暂存区的数据，覆盖工作区。reset HEAD相当于拿版本库的数据，覆盖暂存区。
8、考虑工作区、暂存区、版本库的内容分别为C、B、A
	现在要全部撤销，有两个办法：
	第一个办法：checkout结果为【B、B、A】-->reset HEAD结果为【B、A、A】-->checkout结果为【A、A、A】
	第二个办法：reset HEAD结果为【C、A、A】-->checkout结果为【A、A、A】
#####################################################################################################################
git命令status
1、执行的结果如下：
	niuzibin@ubuntu:~/work/gittest$ git status    
	On branch master
	Changes to be committed:
	(use "git reset HEAD <file>..." to unstage)
	
			modified:   readme.txt
	
	Changes not staged for commit:
	(use "git add <file>..." to update what will be committed)
	(use "git checkout -- <file>..." to discard changes in working directory)
	
			modified:   readme.txt
2、解释如下：
	On branch master				工作的分支
	Changes to be committed:		暂存区没有提交的信息
	Changes not staged for commit:	工作区没有添加到暂存区的信息
#####################################################################################################################
我来打印出来的秘钥的变化
1、



LOG(all)





#####################################################################################################################
#define LOG(g) \
    (cryptdb_logger(log_group::log_ ## g, __FILE__, __LINE__, __func__))
	
LOG(wrapper)

cryptdb_logger(log_group::log_ ## wrapper, __FILE__, __LINE__, __func__)


enum class log_group {
#define __temp_m(n) log_ ## n,
LOG_GROUPS(__temp_m)
#undef __temp_m
};


#####################################################################################################################
看一下每个洋葱层的序列化
1、


#####################################################################################################################
密钥管理的内容
1、替换之后，保持一致。
2、做什么内容？
	秘钥key的管理，加密，解密。
3、接收masterkey，产生seed_key，对seed_key加密保存到embedded_db，从embedded_db读取出来，解密。



#####################################################################################################################
密钥管理的代码修改
1、MasterKey --> AES_Key --> seed_key【洋葱层】



#####################################################################################################################
我先把GetLayKey做好，怎么验证是否做好了？
1、embedded_db中的数据，保持一致。



#####################################################################################################################
如何验证我修改正确？
1、目前的





























